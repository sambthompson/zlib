*** infback.c	Mon Aug 11 16:48:06 2003
--- infback9.c	Mon Sep  8 21:22:46 2003
***************
*** 1,19 ****
! /* infback.c -- inflate using a call-back interface
   * Copyright (C) 1995-2003 Mark Adler
   * For conditions of distribution and use, see copyright notice in zlib.h
   */
  
- /*
-    This code is largely copied from inflate.c.  Normally either infback.o or
-    inflate.o would be linked into an application--not both.  The interface
-    with inffast.c is retained so that optimized assembler-coded versions of
-    inflate_fast() can be used with either inflate.c or infback.c.
-  */
- 
  #include "zutil.h"
! #include "inftrees.h"
  #include "inflate.h"
- #include "inffast.h"
  
  /* function prototypes */
  local void fixedtables OF((struct inflate_state FAR *state));
--- 1,12 ----
! /* infback9.c -- inflate deflate64 data using a call-back interface
   * Copyright (C) 1995-2003 Mark Adler
   * For conditions of distribution and use, see copyright notice in zlib.h
   */
  
  #include "zutil.h"
! #include "infback9.h"
! #include "inftree9.h"
  #include "inflate.h"
  
  /* function prototypes */
  local void fixedtables OF((struct inflate_state FAR *state));
***************
*** 22,33 ****
     strm provides memory allocation functions in zalloc and zfree, or
     Z_NULL to use the library memory allocation functions.
  
!    windowBits is in the range 8..15, and window is a user-supplied
!    window and output buffer that is 2**windowBits bytes.
   */
! int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
  z_stream FAR *strm;
- int windowBits;
  unsigned char FAR *window;
  const char *version;
  int stream_size;
--- 15,24 ----
     strm provides memory allocation functions in zalloc and zfree, or
     Z_NULL to use the library memory allocation functions.
  
!    window is a user-supplied window and output buffer that is 64K bytes.
   */
! int ZEXPORT inflateBack9Init_(strm, window, version, stream_size)
  z_stream FAR *strm;
  unsigned char FAR *window;
  const char *version;
  int stream_size;
***************
*** 37,44 ****
      if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
          stream_size != (int)(sizeof(z_stream)))
          return Z_VERSION_ERROR;
!     if (strm == Z_NULL || window == Z_NULL ||
!         windowBits < 8 || windowBits > 15)
          return Z_STREAM_ERROR;
      strm->msg = Z_NULL;                 /* in case we return an error */
      if (strm->zalloc == (alloc_func)0) {
--- 28,34 ----
      if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
          stream_size != (int)(sizeof(z_stream)))
          return Z_VERSION_ERROR;
!     if (strm == Z_NULL || window == Z_NULL)
          return Z_STREAM_ERROR;
      strm->msg = Z_NULL;                 /* in case we return an error */
      if (strm->zalloc == (alloc_func)0) {
***************
*** 51,58 ****
      if (state == Z_NULL) return Z_MEM_ERROR;
      Tracev((stderr, "inflate: allocated\n"));
      strm->state = (voidpf)state;
!     state->wbits = windowBits;
!     state->wsize = 1U << windowBits;
      state->window = window;
      state->write = 0;
      state->whave = 0;
--- 41,48 ----
      if (state == Z_NULL) return Z_MEM_ERROR;
      Tracev((stderr, "inflate: allocated\n"));
      strm->state = (voidpf)state;
!     state->wbits = 16;
!     state->wsize = 1U << 16;
      state->window = window;
      state->write = 0;
      state->whave = 0;
***************
*** 91,110 ****
          next = fixed;
          lenfix = next;
          bits = 9;
!         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
  
          /* distance table */
          sym = 0;
          while (sym < 32) state->lens[sym++] = 5;
          distfix = next;
          bits = 5;
!         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
  
          /* do this just once */
          virgin = 0;
      }
  #else /* !BUILDFIXED */
! #   include "inffixed.h"
  #endif /* BUILDFIXED */
      state->lencode = lenfix;
      state->lenbits = 9;
--- 81,100 ----
          next = fixed;
          lenfix = next;
          bits = 9;
!         inflate_table9(LENS, state->lens, 288, &(next), &(bits), state->work);
  
          /* distance table */
          sym = 0;
          while (sym < 32) state->lens[sym++] = 5;
          distfix = next;
          bits = 5;
!         inflate_table9(DISTS, state->lens, 32, &(next), &(bits), state->work);
  
          /* do this just once */
          virgin = 0;
      }
  #else /* !BUILDFIXED */
! #   include "inffix9.h"
  #endif /* BUILDFIXED */
      state->lencode = lenfix;
      state->lenbits = 9;
***************
*** 114,141 ****
  
  /* Macros for inflateBack(): */
  
- /* Load returned state from inflate_fast() */
- #define LOAD() \
-     do { \
-         put = strm->next_out; \
-         left = strm->avail_out; \
-         next = strm->next_in; \
-         have = strm->avail_in; \
-         hold = state->hold; \
-         bits = state->bits; \
-     } while (0)
- 
- /* Set state from registers for inflate_fast() */
- #define RESTORE() \
-     do { \
-         strm->next_out = put; \
-         strm->avail_out = left; \
-         strm->next_in = next; \
-         strm->avail_in = have; \
-         state->hold = hold; \
-         state->bits = bits; \
-     } while (0)
- 
  /* Clear the input bit accumulator */
  #define INITBITS() \
      do { \
--- 104,109 ----
***************
*** 237,243 ****
     inflateBack() can also return Z_STREAM_ERROR if the input parameters
     are not correct, i.e. strm is Z_NULL or the state was not initialized.
   */
! int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
  z_stream FAR *strm;
  in_func in;
  void FAR *in_desc;
--- 205,211 ----
     inflateBack() can also return Z_STREAM_ERROR if the input parameters
     are not correct, i.e. strm is Z_NULL or the state was not initialized.
   */
! int ZEXPORT inflateBack9(strm, in, in_desc, out, out_desc)
  z_stream FAR *strm;
  in_func in;
  void FAR *in_desc;
***************
*** 354,366 ****
              DROPBITS(5);
              state->ncode = BITS(4) + 4;
              DROPBITS(4);
! #ifndef PKZIP_BUG_WORKAROUND
!             if (state->nlen > 286 || state->ndist > 30) {
!                 strm->msg = (char *)"too many length or distance symbols";
                  state->mode = BAD;
                  break;
              }
- #endif
              Tracev((stderr, "inflate:       table sizes ok\n"));
  
              /* get code length code lengths (not a typo) */
--- 322,332 ----
              DROPBITS(5);
              state->ncode = BITS(4) + 4;
              DROPBITS(4);
!             if (state->nlen > 286) {
!                 strm->msg = (char *)"too many length symbols";
                  state->mode = BAD;
                  break;
              }
              Tracev((stderr, "inflate:       table sizes ok\n"));
  
              /* get code length code lengths (not a typo) */
***************
*** 375,381 ****
              state->next = state->codes;
              state->lencode = (code const FAR *)(state->next);
              state->lenbits = 7;
!             ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                  &(state->lenbits), state->work);
              if (ret) {
                  strm->msg = (char *)"invalid code lengths set";
--- 341,347 ----
              state->next = state->codes;
              state->lencode = (code const FAR *)(state->next);
              state->lenbits = 7;
!             ret = inflate_table9(CODES, state->lens, 19, &(state->next),
                                  &(state->lenbits), state->work);
              if (ret) {
                  strm->msg = (char *)"invalid code lengths set";
***************
*** 438,445 ****
              state->next = state->codes;
              state->lencode = (code const FAR *)(state->next);
              state->lenbits = 9;
!             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
!                                 &(state->lenbits), state->work);
              if (ret) {
                  strm->msg = (char *)"invalid literal/lengths set";
                  state->mode = BAD;
--- 404,411 ----
              state->next = state->codes;
              state->lencode = (code const FAR *)(state->next);
              state->lenbits = 9;
!             ret = inflate_table9(LENS, state->lens, state->nlen,
!                             &(state->next), &(state->lenbits), state->work);
              if (ret) {
                  strm->msg = (char *)"invalid literal/lengths set";
                  state->mode = BAD;
***************
*** 447,454 ****
              }
              state->distcode = (code const FAR *)(state->next);
              state->distbits = 6;
!             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
!                             &(state->next), &(state->distbits), state->work);
              if (ret) {
                  strm->msg = (char *)"invalid distances set";
                  state->mode = BAD;
--- 413,421 ----
              }
              state->distcode = (code const FAR *)(state->next);
              state->distbits = 6;
!             ret = inflate_table9(DISTS, state->lens + state->nlen,
!                             state->ndist, &(state->next), &(state->distbits),
!                             state->work);
              if (ret) {
                  strm->msg = (char *)"invalid distances set";
                  state->mode = BAD;
***************
*** 458,473 ****
              state->mode = LEN;
  
          case LEN:
-             /* use inflate_fast() if we have enough input and output */
-             if (have >= 6 && left >= 258) {
-                 RESTORE();
-                 if (state->whave < state->wsize)
-                     state->whave = state->wsize - left;
-                 inflate_fast(strm, state->wsize);
-                 LOAD();
-                 break;
-             }
- 
              /* get a literal, length, or end-of-block code */
              for (;;) {
                  this = state->lencode[BITS(state->lenbits)];
--- 425,430 ----
***************
*** 607,613 ****
      return ret;
  }
  
! int ZEXPORT inflateBackEnd(strm)
  z_stream FAR *strm;
  {
      if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
--- 564,570 ----
      return ret;
  }
  
! int ZEXPORT inflateBack9End(strm)
  z_stream FAR *strm;
  {
      if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
*** inftrees.c	Sun Sep  7 10:59:10 2003
--- inftree9.c	Mon Sep  8 20:54:36 2003
***************
*** 1,15 ****
! /* inftrees.c -- generate Huffman trees for efficient decoding
   * Copyright (C) 1995-2003 Mark Adler
   * For conditions of distribution and use, see copyright notice in zlib.h
   */
  
  #include "zutil.h"
! #include "inftrees.h"
  
  #define MAXBITS 15
  
! const char inflate_copyright[] =
!    " inflate 1.2.0.5 Copyright 1995-2003 Mark Adler ";
  /*
    If you use the zlib library in a product, an acknowledgment is welcome
    in the documentation of your product. If for some reason you cannot
--- 1,15 ----
! /* inftree9.c -- generate Huffman trees for efficient decoding
   * Copyright (C) 1995-2003 Mark Adler
   * For conditions of distribution and use, see copyright notice in zlib.h
   */
  
  #include "zutil.h"
! #include "inftree9.h"
  
  #define MAXBITS 15
  
! const char inflate9_copyright[] =
!    " inflate9 1.2.0.5 Copyright 1995-2003 Mark Adler ";
  /*
    If you use the zlib library in a product, an acknowledgment is welcome
    in the documentation of your product. If for some reason you cannot
***************
*** 29,35 ****
     table index bits.  It will differ if the request is greater than the
     longest code or if it is less than the shortest code.
   */
! int inflate_table(type, lens, codes, table, bits, work)
  codetype type;
  unsigned short FAR *lens;
  unsigned codes;
--- 29,35 ----
     table index bits.  It will differ if the request is greater than the
     longest code or if it is less than the shortest code.
   */
! int inflate_table9(type, lens, codes, table, bits, work)
  codetype type;
  unsigned short FAR *lens;
  unsigned codes;
***************
*** 59,76 ****
      unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
      static const unsigned short lbase[31] = { /* Length codes 257..285 base */
          3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
!         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
      static const unsigned short lext[31] = { /* Length codes 257..285 extra */
          16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
!         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 192, 78};
!     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
          1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
          257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
!         8193, 12289, 16385, 24577, 0, 0};
!     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
          16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
          23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
!         28, 28, 29, 29, 64, 64};
  
      /*
         Process a set of code lengths to create a canonical Huffman code.  The
--- 59,76 ----
      unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
      static const unsigned short lbase[31] = { /* Length codes 257..285 base */
          3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
!         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 3, 0, 0};
      static const unsigned short lext[31] = { /* Length codes 257..285 extra */
          16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
!         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 32, 192, 78};
!     static const unsigned short dbase[32] = { /* Distance codes 0..31 base */
          1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
          257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
!         8193, 12289, 16385, 24577, 32769, 49153};
!     static const unsigned short dext[32] = { /* Distance codes 0..31 extra */
          16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
          23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
!         28, 28, 29, 29, 30, 30};
  
      /*
         Process a set of code lengths to create a canonical Huffman code.  The
*** inftrees.h	Sun Aug 10 15:15:50 2003
--- inftree9.h	Mon Sep  8 20:54:51 2003
***************
*** 1,4 ****
! /* inftrees.h -- header to use inftrees.c
   * Copyright (C) 1995-2003 Mark Adler
   * For conditions of distribution and use, see copyright notice in zlib.h
   */
--- 1,4 ----
! /* inftree9.h -- header to use inftree9.c
   * Copyright (C) 1995-2003 Mark Adler
   * For conditions of distribution and use, see copyright notice in zlib.h
   */
***************
*** 50,55 ****
      DISTS
  } codetype;
  
! extern int inflate_table OF((codetype type, unsigned short FAR *lens,
                               unsigned codes, code FAR * FAR *table,
                               unsigned FAR *bits, unsigned short FAR *work));
--- 50,55 ----
      DISTS
  } codetype;
  
! extern int inflate_table9 OF((codetype type, unsigned short FAR *lens,
                               unsigned codes, code FAR * FAR *table,
                               unsigned FAR *bits, unsigned short FAR *work));
